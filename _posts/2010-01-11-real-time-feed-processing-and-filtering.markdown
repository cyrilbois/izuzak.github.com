---
layout: post
title: Real-time feed processing and filtering
commentIssueId: 8
---

_(this post was initially published on [my previous blog on wordpress.com](http://izuzak.wordpress.com/), you can visit it [here](http://izuzak.wordpress.com/2010/01/11/real-time-feed-processing-and-filtering/) and see the [comments](http://izuzak.wordpress.com/2010/01/11/real-time-feed-processing-and-filtering/#comments))_

<em>This is another lengthy post so I'm writing a brief overview as an introduction.</em>
<h2>Introduction</h2>
This post is about web syndication feeds (RSS and ATOM), technologies for real-time delivery of feeds (PubSubHubBub, RSSCloud) and two opportunities I believe could help make these technologies better and widen their adoption: <strong>real-time feed processing/filtering and end-user selection of processing/filtering services</strong>. First, I'll write about my experience with polling-based feed processing services from developing Feed-buster, a feed-enhancing service for use in FriendFeed. Next, I'll give a short overview of PubSubHubBub (PSHB) and several ways of integrating feed filtering and processing functionalities into the PSHB ecosystem without changing the PSHB protocol. Lastly, I'll try to argument why there should be a better solution and outline an idea for an extension to the PSHB protocol.

Before I continue, I have to acknowledge that I've discussed some of these ideas with <a href="http://twitter.com/julien51" target="_blank">Julien </a><a href="http://twitter.com/julien51" target="_blank">Genestoux</a> (the guy behind <a href="http://superfeedr.com/" target="_blank">Superfeedr</a>) and <a href="http://www.google.com/profiles/bslatkin" target="_blank">Brett </a><a href="http://www.google.com/profiles/bslatkin" target="_blank">Slatkin</a> (one of <a href="http://code.google.com/p/pubsubhubbub/" target="_blank">PSHB</a> developers) several months ago. Julien and I were even starting to draft a proposal for a PSHB extension for supporting filters, however, due to other stuff in our lives, we didn't really get anywhere.
<h2>Polling-based feed processing and filtering - experience from FriendFeed and Feed-Buster</h2>
<a href="http://friendfeed.com/" target="_blank">FriendFeed</a> is a social-networking web application that aggregates updates from social media sites and blogs that expose an <a href="http://en.wikipedia.org/wiki/RSS" target="_blank">RSS</a> or <a href="http://en.wikipedia.org/wiki/Atom_feed" target="_blank">Atom</a> feed of their content. You give FriendFeed the URI of an RSS/Atom feed and it fetches and displays short snippets of updates as they appear in the feed. In most cases this means that only the title and a short snippet of the description of the new item are shown. For feeds that have <a href="http://en.wikipedia.org/wiki/Media_RSS" target="_blank">special XML tags</a> that list media resources in the update, the images/videos/audio content from the new feed item is also displayed. The problem is that <strong>most RSS/Atom feeds don't have these media XML tags </strong>since webapps that create the feeds (e.g. blogging engines) don't bother defining them. This gave a not-very-user-friendly look to most FriendFeed user pages which were just a long list of update titles and possibly snippets.

<a href="http://code.google.com/p/feed-buster/" target="_blank"><img class="aligncenter" title="Feed-buster" src="/images/fbdemopic.png" alt="Feed-buster" width="60%" /></a>

So I built <a href="http://code.google.com/p/feed-buster/" target="_blank"><strong>Feed-buster</strong></a><strong>, an </strong><a href="http://code.google.com/appengine/" target="_blank"><strong>AppEngine</strong></a><strong> service that inserts these MediaRSS tags into feeds that don't have them</strong>. Since the only thing FriendFeed accepts from users are URIs pointing to feeds - the service must be callable by requesting a single URI with a HTTP GET request and must return an RSS/Atom feed in a HTTP response. Here's how Feed-buster works:
<ol>
	<li>An URI to an RSS/Atom feed is supplied as a query parameter of a HTTP GET request to the service. E.g. http://feed-buster.appspot.com/mediaInjection?inputFeedUrl=http://myfeed.com/atom.</li>
	<li>The service fetches the target feed, finds all the images, video and audio URIs and inserts the special XML tags for each one back into the feed.</li>
	<li>The service returns the modified feed as the content of a HTTP response.</li>
</ol>
To use the service, the user would obtain an URI of an RSS/Atom feed, create the corresponding Feed-buster URI by appending the feed URI to the Feed-buster service URI and pass it to FriendFeed (1). Suppose that the feed is not real-time enabled (i.e. a PSHB or RSSCloud feed). In this case, every 45 minutes FF will poll for updates - send a HTTP GET request to the service (2), the service will fetch the original feed (3), process the feed (4) and return a HTTP response with the processed feed (5).

<img class="aligncenter" title="Feed-buster architecture" src="/images/fb.png" alt="Feed-buster architecture" width="60%" />

Feed-buster is a<strong> feed processing service</strong>: it takes a feed URI as input and returns the feed it points to as output, potentially modifying any subset of feed items (but not removing any). <strong>Feed filtering services</strong> are similar: they take a feed URI as input and return the feed it points to as output, potentially removing any subset of feed items (but not modifying any). The difference is subtle and both terms could be unified under "feed processing". Furthermore, this model of feed processing/filtering was nothing new at the time I developed Feed-buster, there were <a href="http://www.readwriteweb.com/archives/6_ways_to_filter_your_rss_feeds.php" target="_blank">numerous services</a> that filtered/processed feeds based on user preferences. The best example is probably <a href="http://pipes.yahoo.com/pipes/" target="_blank"><strong>Yahoo! Pipes</strong></a><strong> which enables anyone to create a filtering/processing pipe a publish it as a service</strong> just like Feed-buster.

Lessons learned:
<ul>
	<li>Feed-buster is very <strong>simple to use</strong> and this helped to make it popular (appending an URI to another URI is something everyone can do).</li>
	<li>Feed-buster's model of use is based on <strong>separation of filtering/processing services as individual entities in the ecosystem</strong> which enables that these services be developed independently of publishers and subscribers. Applications that enable other applications make ecosystems grow.</li>
	<li>Polling is bad (1). Because AppEngine applications have a <a href="http://code.google.com/appengine/docs/quotas.html" target="_blank">fixed free daily quota</a> for consumed resources, when the number of feeds the service processed increased -<strong> the daily quota was exhausted before the end of the day</strong> because FF polls the service for each feed every 45 minutes. See the AppEngine resource graph below for a very clear visual explanation :). Of course, I implemented several caching mechanisms in the service and it helped, but not enough.</li>
	<li>Polling is bad (2). Real-time feed delivery arrived in the form of <a href="http://code.google.com/p/pubsubhubbub/" target="_blank">PubSubHubBub</a> and <a href="http://rsscloud.org/" target="_blank">RSSCloud</a>, <strong>everyone loved it and wanted everything to be real-time</strong>. But Feed-buster feeds weren't real-time. Even if the original feed supported PSHB, the output feed didn't (since it Feed-buster wasn't a PSHB publisher or hub). Feed-buster users were not happy.</li>
</ul>

<a href="/images/fbgae.png"><img class="aligncenter" title="Feed-buster - AppEngine request processing duration graph" src="/images/fbgae.png" alt="Feed-buster - AppEngine request processing duration graph" width="576" height="258" /></a>


<h2>PubSubHubBub - real-time feed delivery</h2>
<a href="http://code.google.com/p/pubsubhubbub/" target="_blank"><strong>PubSubHubBub</strong></a><strong> is a server-to-server publish-subscribe protocol for federated delivery of feed updates</strong>. Without going into a lot of detail, the basic architecture consists of publishers, subscribers and hubs which interact in the following way:
<div id="_mcePaste">
<ol>
	<li>A feed publisher declares its hub in its Atom or RSS XML file and a subscriber initially fetches the feed to discover the hub.</li>
	<li>The subscriber subscribes to the discovered hub declaring the feed URI it wishes to subscribe to and an URI at which it wants to receive updates.</li>
	<li>When the publisher next updates the feed, it pings the hub saying that there's an update and the hub fetches the published feed.</li>
	<li>The hub multicasts the new/changed content out to all registered subscriber.</li>
</ol>
</div>

<a href="/images/pshbarch.png"><img class="aligncenter" title="PubSubHubBub ecosystem and protocol" src="/images/pshbarch.png" alt="PubSubHubBub ecosystem and protocol" width="398" height="107" /></a>

And this gives us real-time feed delivery. <strong>But what about real-time filtering and processing?</strong> How would a real-time-enabled version of Feed-buster be built? Of course, there are <a href="http://blog.postrank.com/2009/10/filtering-the-real-time-web/" target="_blank">a lot more reasons for doing this</a>, both from business and engineering perspectives.
<h2>Real-time feed processing and filtering (take 1)</h2>
So, the idea is to <strong>extend the PSHB ecosystem with filtering/processing services in some way</strong>. First, here are a few ideas for doing this <strong>without extending the PSHB protocol</strong>:
<ol>
	<li><strong>Integrating filtering/processing services into publishers.</strong> This means that the publisher would expose not only the original feed, but also a feed for each filter/processing defined by the subscriber. For example, <a href="http://www.twitter.com" target="_blank">Twitter</a> has a single feed of all updates for a specific user, a feed for updates from that user containing the string "hello", updates not containing "world", updates written in English, and so on.</li>
	<li><strong>Integrating filtering/processing services into subscribers. </strong>This means that the subscriber application would subscribe to feeds and filter/process them on it's own. It's not exactly the same thing but, for example, FriendFeed subscribes to feeds you want it to aggregate and later you can filter the content from within the FriendFeed application -- this is called search, as in Twitter, but basically means filter.</li>
	<li><strong>Integrating filtering/processing services into hubs. </strong>This means that a hub would not only deliver feed updates, but process and filter them also. This would cause a large number of hubs to be developed, each implementing some filter or processing functionality. If you want to filter a feed - subscribe to a hub that implements that filter. If you want a new filter - build a new hub. However, if an end-user tells a subscriber application to subscribe to a feed with a specific URI, the subscriber will subscribe to a hub specified in the feed, not to the filtering/processing hub (since that hub wasn't  specified in any way). A possible way for enabling end-users to select which hub they want to use is to generate dummy feeds on filtering/processing hubs (e.g. http://www.hubforfiltering.com/http://www.myfeed.com/atom). The contents of this dummy feed is the same as the contents of the original feed but with a simple difference - the hub elements from the original feed are removed and a hub element for new hub is inserted. This way, when the end-user passes the dummy feed URI to the subscriber application, the application will subscribe to the filtering/processing hub, not the original one. The filtering/processing hub then subscribes to the original hub to receive updates, filters/processes received updates and notifies the subscriber.</li>
	<li><strong>Masking the filtering/processing services as the subscriber which then notifies the real subscriber. </strong>I'm not sure this is possible (too lazy to go through the PSHB spec), but in theory, here's how it would work. The subscriber would obtain an URI pointing to the filtering/processing service for which the service would know what the real subscriber notification callback is (e.g. http://www.filter.com?subscriber=http://www.realsubscriber.com/callback). The subscriber would subscribe to the hub using the obtained URI. When the publisher publishes an update, the hub would pass the update to the filtering/processing service thinking it was the subscriber. The filtering/processing service would do it's thing and pass the update to the real subscriber. It's unclear though how this would be done by end-users since they'd have to know the subscriber application's callback URI.</li>
</ol>
<strong>All of these approaches have their pros and cons.</strong> Some are not easily or at all end-user definable, some may introduce unnecessary duplication of notifications, some introduce delivery of unwanted notifications, some do not support reuse of existing infrastructure and cause unnecessary duplication of systems, and most do not promote the development of filtering/processing services as a separate part of the ecosystem.
<h2>Real-time feed processing and filtering (take 2)</h2>
What I believe is needed is an architecture and protocol which supports three things. First - <strong>filtering/processing services as a separate part of the ecosystem</strong>. Since publishers and subscribers can't possibly anticipate and implement every possible filter and processing service, this will enable a stream of development activity resulting in services with different functionality, performance and business models. Again, applications enabling other applications help software ecosystems grow.

Second - <strong>a scalable processing model where hubs invoke filtering/processing services</strong>. Regarding architectural decisions on where filtering/processing should be applied, there's a paper (<a href="http://portal.acm.org/citation.cfm?id=343622" target="_blank">citation</a>, <a href="http://eprints.kfupm.edu.sa/22490/1/22490.pdf" target="_blank">pdf</a>) from 2000. on "<em>Achieving Scalability and Expressiveness in an Internet-scale Event Notification Service</em>" which states two principles:

<blockquote>

Downstream replication: A notification should be routed in one copy as far as possible and should be replicated only downstream, that is, as close as possible to the parties that are interested in it.

Upstream evaluation: Filters are applied and patterns are assembled upstream, that is, as close as possible to the sources of (patterns of) notifications.

</blockquote>

In short, these principles state that <strong>filtering services should be applied as close to the publisher</strong> as possible so notifications that nobody wants don't waste network resources. However, <strong>processing services should be applied as close to the subscriber</strong> so that the original update may be transported through the network as a single notification for as long as possible. In cases where there's a single hub between the publisher and subscriber, the same hub would invoke both processing and filtering services. However, in more complex hub network topologies different hubs would invoke different types of services based on their topological proximity to the subscriber/publisher.

Third and last - <strong>end-user selection of these services</strong>. When 3rd party filtering/processing services exist - how will they be chosen for a particular subscription? In my opinion, this must be done by end-users and thus there must be an easy way of doing it. The first thing that comes to mind would be to extend the subscription user-interface (UI) exposed to users of subscriber applications. E.g. instead of just showing a textbox for defining the feed the users wants to follow, there could be an "Advanced" menu with textboxes for defining filtering and processing services.

<a href="/images/pshbnew.png"><img class="aligncenter" title="New PSHB architecture and protocol outline" src="/images/pshbnew.png" alt="New PSHB architecture and protocol outline" width="454" height="282" /></a>

No matter how cool I think this would be as a core part of the PSHB protocol, it's probably a better idea doing it as an extension (as a first step?). So here's what the extension would define:
<ol>
	<li>The subscription part of the protocol additionally <strong>enables subscribers to define two lists of URIs </strong>when subscribing to a hub<strong>, one declaring the list of filtering services and the other the list of processing services </strong>that should be applied.</li>
	<li><strong>Hubs are responsible </strong>not only for delivery of notifications but also<strong> for calling filtering/processing services</strong> on those notifications and receiving their responses. An inter-hub subscription negotiation/propagation <strong>mechanism that enables the optimal placement of subscription-defined filters and processing services in the delivery flow</strong>. In case of a single hub, nothing needs to be done since the hub invokes both types of services. However, in case of two hubs, the hub which first received the subscription would locally subscribe to the second hub stating only the filtering services while processing services would not be sent upstream. Thus, the hub closer to the subscriber would be responsible for invoking processing services, and the hub closer to the publisher would be responsible for invoking filtering services. This could, I believe, be generalized and formalized for any kind of hub network topology.</li>
	<li>When an update is published, hubs responsible for invoking filtering or processing services must do so before forwarding the notifications downstream. There are several performance-related issues which need to be addressed here. First, <strong>the invocation of filtering/processing services should be asynchronous, </strong><a href="http://www.webhooks.org/" target="_blank"><strong>webhook</strong></a><strong>-based</strong> (the hub calls a service passing an URI to which the result of processing should be POSTed). Second, <strong>invocation of services on a specific hub for a specific notification should be done in parallel</strong>, except if multiple processing services were defined for a single subscription in which case those processing services must be invoked serially (filters can always be invoked in parallel). Third, there's a not-so-clear trade-off between a) waiting for all invoked filters to respond and sending a single notification carrying all metadata regarding which filters it satisfied and b) <strong>sending  multiple notifications containing the same content but different metadata regarding which filters were satisfied </strong>(e.g. as each filter responds). Since all filters will not respond at the same time (some will respond sooner, some later and some possibly never) - waiting for all filters invoked in parallel before continuing seems contradictory to the constraint of real-time delivery. On the other hand, creating multiple notifications with the same data will introduce an overhead in the network. Overall, I believe that the overhead will not be substantial since there will not be many duplicates -- this can even be regulated as a hub-level parameter e.g. one notification for services returning in under 2 seconds, one for under 10 second, and one for everything else, and the benefit is basically a necessity.</li>
</ol>
<h2>Conclusion</h2>
Of course I didn't consider all aspects of the problem and there are a lot more points of view to be considered, from is it legal to change content in a feed and in what way to how do we make this extension secure and fault tolerant? Nevertheless, I believe that the need and expertise are here and that it's an <strong>opportunity to make the real time web better</strong>. What are your ideas for extending real-time content delivery technologies? <a href="http://www.twitter.com/izuzak" target="_blank">@izuzak</a>
