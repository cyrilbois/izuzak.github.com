---
layout: post
title: Why understanding REST is hard and what we should do about it - systematization, models and terminology for REST
commentIssueId: 9
---
<em><strong>EDIT 29 August 2011: I've published a paper on the FSM-based formalism for describing RESTful systems at the <a href="http://icwe2011.webengineering.org/">ICWE 2011 conference</a>. The formalism presented in the paper is a more detailed and advanced version of the one presented in the second part of this blog post. Links for downloading the paper and presentation slides are in the <a href="http://ivanzuzak.info/#talks">talks and papers section</a>.</strong></em>

<em><strong>EDIT 25 January 2012: I've published another paper on the FSM-based formalism for RESTful systems, this time in the <a href="http://www.rintonpress.com/journals/jwe/">Journal of Web Engineering</a>. This paper is again a revised and extended version of the previous paper. Furthermore, the paper explores the practical challenges and benefits of using the presented formalism. Again, for more details see the <a href="http://ivanzuzak.info/#talks">talks and papers section</a>.</strong></em>

<em>This is going to be another long post, so I'm using the introduction as an overview again.</em>

<em><span style="font-family:Verdana;font-style:normal;line-height:normal;"> </span></em>
<h3 style="font-size:12pt;text-align:left;"><strong>Introduction</strong></h3>
<p style="text-align:justify;">This post is about <strong>understanding </strong><a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank"><strong>REST</strong></a>, the <a href="http://en.wikipedia.org/wiki/Software_architecture" target="_blank">software architectural</a> <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/software_arch.htm#sec_1_5" target="_blank">style</a> behind the <a href="http://en.wikipedia.org/wiki/WWW" target="_blank">World Wide Web</a>. My Ph.D. research, which I'll write about some other time, pushed me on the road of REST and over the last year I've been reading <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank">lots</a> <a href="http://portal.acm.org/citation.cfm?id=1367606" target="_blank">of</a> <a href="http://www.vs.inf.ethz.ch/res/papers/dguinard_09_WOTMashups.pdf" target="_blank">research</a> <a href="http://portal.acm.org/citation.cfm?id=1287624.1287660" target="_blank">papers</a>, <a href="http://www.amundsen.com/blog/" target="_blank">lots</a> <a href="http://www.nordsc.com/blog/" target="_blank">of</a> <a href="http://roy.gbiv.com/untangled/" target="_blank">blogs</a>, <a href="http://tech.groups.yahoo.com/group/rest-discuss/" target="_blank">lots</a> <a href="http://lists.w3.org/Archives/Public/public-lod/" target="_blank">of</a> <a href="http://lists.w3.org/Archives/Public/www-tag/" target="_blank">mailing</a> <a href="http://lists.w3.org/Archives/Public/ietf-http-wg/" target="_blank">lists</a>, <a href="http://twitter.com/mamund/status/10672950825" target="_blank">lots</a> <a href="http://twitter.com/dret/status/9930545464" target="_blank">of</a> <a href="http://twitter.com/stilkov/status/9029759744" target="_blank">tweets</a>, <a href="http://www.youtube.com/watch?v=YCcAE2SCQ6k" target="_blank">lots</a> <a href="http://www.davidgiard.com/2010/03/15/MikeAmundsenOnHTTPAndREST.aspx" target="_blank">of</a> <a href="http://www.infoq.com/interviews/Restfulie" target="_blank">videos</a>, <a href="http://rest.blueoxen.net/cgi-bin/wiki.pl" target="_blank">wikis</a>, <a href="http://www.softwarearchitecturebook.com/" target="_blank">books</a> and <a href="http://rest.hackyhack.net/" target="_blank">IRC transcripts</a> on REST and I've also recently started the <em>This Week in REST</em> <a href="http://rest.blueoxen.net/cgi-bin/wiki.pl?RESTWeekly" target="_blank">wiki</a> and <a href="http://thisweekinrest.wordpress.com/" target="_blank">blog</a>. In other words, I've read almost everything I could find on REST. So, in the first part of this post I'll write about several thoughts which stuck with me while researching REST:</p>

<ol style="text-align:justify;">
	<li><strong>REST is and will continue to be important</strong> - it's the foundation of the WWW and will be the foundation of its future stages and dimensions, like the <a href="http://en.wikipedia.org/wiki/Semantic_Web" target="_blank">Semantic Web</a> and the <a href="http://en.wikipedia.org/wiki/Web_of_Things" target="_blank">Web of Things</a>.</li>
	<li><strong>Understanding REST is hard</strong> - the material on REST is fragmented and there is no clearly defined and systematized terminology or formal models used in discussions.</li>
	<li style="text-align:justify;"><strong>We can and should fix the problem</strong> - there are enough motivated and smart people who can, through an open and collaborative process, create a better way of fully understanding REST.</li>
</ol>
<p style="text-align:justify;">In the second part of the post I'll add to the pile of scattered fragments on understanding RESTful systems and <strong>describe an abstract model of a simplified REST user-agent using </strong><strong><a href="http://en.wikipedia.org/wiki/Finite_state_machine" target="_blank">finite state machines</a></strong>. It's a very basic model but serves the purpose of showing that it is both possible and useful to develop such formal models.</p>
<p style="text-align:justify;">I hope this post will motivate people involved and interested in REST to contribute to a process for improving the understanding of REST. I was planing to write my thoughts as a paper for the <a href="http://www.ws-rest.org/" target="_blank">First International Workshop on RESTful Design (WS-REST 2010)</a> but didn't have enough time. Nevertheless, I hope that people who are going to the workshop will talk about this issue. I'll start a thread on the REST mailing list for following up on these ideas, so please comment there if you want to join the discussion (<strong><em>EDIT: thread is </em></strong><strong><em><a href="http://tech.groups.yahoo.com/group/rest-discuss/messages/15200?threaded=1&amp;m=e&amp;var=1&amp;tidx=1" target="_blank">here</a><span style="font-weight:normal;"><span style="font-style:normal;">)</span></span></em></strong>.</p>

<h2 style="text-align:justify;">Representational State Transfer and why it's important</h2>
<p style="text-align:justify;">Although this post is about understanding the REpresentational State Transfer (REST) software architectural style, I'm not going to write another REST introduction. If you don't know anything about REST, start from the <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer" target="_blank">wikipedia article</a> and go from there.</p>

<a href="http://www.flickr.com/photos/psd/2918889380/" target="_blank"><img class="aligncenter" src="http://farm4.static.flickr.com/3175/2918889380_994055f2f9_b.jpg" width="202" height="256" /></a>

<p style="text-align:justify;">What's more important for this post is that <strong>REST is and will continue to be an essential part of the WWW</strong>.  First, through the <a href="http://tools.ietf.org/html/rfc3986" target="_blank">Web's</a> <a href="http://tools.ietf.org/id/draft-fielding-http-p" target="_blank">core</a> <a href="http://dev.w3.org/html5/spec/Overview.html" target="_blank">technologies</a>, REST is responsible for most of the <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer#Key_goals" target="_blank">good properties of the current Web</a> as a large-scale network-based system. Second, REST principles guide the development of both the next "major" generations of the Web, like the <a href="http://en.wikipedia.org/wiki/Semantic_Web" target="_blank">Semantic Web</a>, the <a href="http://en.wikipedia.org/wiki/Web_of_Things" target="_blank">Web of Things</a> and the <a href="http://en.wikipedia.org/wiki/Real_time_web" target="_blank">Real-time Web</a>, and the "minor" incremental <a href="http://tools.ietf.org/html/draft-nottingham-site-meta-05" target="_blank">changes</a> <a href="http://tools.ietf.org/html/draft-duerst-iri-bis" target="_blank">of</a> <a href="http://tools.ietf.org/html/draft-hammer-discovery" target="_blank">continuous</a> <a href="http://www.w3.org/2001/tag/group/track/issues/31" target="_blank">evolution</a>. Whereas the Semantic Web is about <a href="http://en.wikipedia.org/wiki/Resource_Description_Framework" target="_blank">exposing</a> and <a href="http://en.wikipedia.org/wiki/Linked_Data" target="_blank">interlinking</a> data on the WWW, the Web of Things is about <a href="http://www.slideshare.net/misterdom/web-of-things-connecting-people-and-objects-on-the-web-3425316" target="_blank">connecting and exposing</a> every physical thing to it and the Real-time Web is about <a href="http://code.google.com/p/pubsubhubbub/" target="_blank">real-time access</a> to that data and things. Therefore, understanding the <a href="http://www.w3.org/TR/webarch/" target="_blank">Web today</a>, it's <a href="http://journal.webscience.org/146/" target="_blank">future evolution</a> and the <a href="http://bitworking.org/projects/atom/rfc5023.html" target="_blank">whole</a><a href="http://tools.ietf.org/html/draft-nottingham-http-link-header" target="_blank"> technology</a> <a href="http://www.w3.org/TR/rdf-sparql-query/" target="_blank">jungle</a> <a href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol" target="_blank">on</a> <a href="http://wiki.webhooks.org/" target="_blank">top</a> is based on the understanding of REST. Third, REST is important as a research subject on its own (although some people <a href="http://www.subbu.org/blog/2009/07/is-this-restful" target="_blank">think it isn't</a> <strong><em>EDIT: Subbu elaborated on this misunderstanding below in the comment section</em></strong>) and will be <a href="http://www2009.org/proceedings/pdf/p911.pdf" target="_blank">analyzed</a> and built upon to define <a href="http://www.erenkrantz.com/CREST/" target="_blank">new</a> <a href="http://www.ics.uci.edu/~rohit/Khare-Thesis-FINAL.pdf" target="_blank">architectural</a> <a href="http://homepages.cwi.nl/~arie/papers/spci/spiar-jss.pdf" target="_blank">styles</a>.</p>

<h2>Understanding REST</h2>
<p style="text-align:justify;">In my experience, <strong>understanding REST is far from easy</strong>. Of course, not everyone needs to understand REST and different people may want or need to understand REST at different levels and depths. However, despite it being a highly technical and academic concept not everyone should easily and fully grasp, I think it's hard even for people aimed at - computer scientists, software engineers and web architects. After reading everything I could find on REST and the WWW, here are the problems I believe are responsible for this:</p>
<p style="text-align:justify;">

<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_3_1"><img class="aligncenter" src="http://www.codeproject.com/KB/aspnet/NoteOnWebApplications/Figure2.gif" width="320" height="145" /></a>

First, <strong>the REST master reference</strong>, <a href="http://www.ics.uci.edu/~fielding/" target="_blank">Roy Fielding's</a> <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank">doctoral dissertation</a> (and subsequent <a href="http://portal.acm.org/citation.cfm?id=514183.514185" target="_blank">academic</a> <a href="http://portal.acm.org/citation.cfm?id=337228" target="_blank">papers</a>), <strong>is not completely suitable for fully understanding REST</strong>. For a doctoral dissertation, it's severely lacks images explaining important concepts in the two <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_2" target="_blank">key</a> <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm#sec_5_3" target="_blank">sections</a> on REST. However, I bet everyone knows the single image in those sections almost by heart from how much it's being repeated everywhere (for those who don't, that's the image on the right). The same could be said for the lack of (formal) models to describe specific properties, elements or views of REST, like <a href="http://en.wikipedia.org/wiki/HATEOAS" target="_blank">HATEOAS</a>. It's as if the very clean and systematic approach of explaining <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/software_arch.htm" target="_blank">software architecture</a> and <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/net_arch_styles.htm" target="_blank">network-based architectural styles</a> present in the first few chapters of his Ph.D. somehow vanished in those two sections. I am aware that there are no formal models for defining architectural styles as a whole (at least, <a href="http://csse.usc.edu/~mehta/phd/dissertation.pdf" target="_blank">there weren't any then</a>), but using models like <a href="http://en.wikipedia.org/wiki/Finite-state_machine" target="_blank">state machines</a>, <a href="http://en.wikipedia.org/wiki/Petri_net" target="_blank">Petri nets</a> or <a href="http://en.wikipedia.org/wiki/Process_calculus" target="_blank">process calculi</a> to describe and explain parts of it would have definitely been of great benefit. It's that absolute clarity of formal models that helps when you need to have a complete grasp of a concept. Furthermore, since models are abstract methods for explaining specific problems, people only need to research the underlying model after which the specific use of the model is unambiguously clear. And just to be clear, I think Roy's dissertation is overall well written and has had a big impact on both the academia and industry, and I very well know that making everyone on the planet happy with a research paper is idiotic (looking for a good Ph.D. comics reference for this), but I still wish those two sections were a bit more thorough and polished.</p>
<p style="text-align:justify;">Second, since Roy's dissertation doesn't have clear answers for all questions, people start discussions over understanding specific parts of REST all over the Web. <strong>Relevant discussions are scattered</strong> over many mailing lists, blogs, Twitter accounts, wikis, academic papers, videos and even IRC transcripts (see the introduction for links to some of these). More often than not these <strong>discussion are not focused on REST</strong> per se, but <a href="http://derivadow.com/2010/02/18/the-problem-with-breadcrumb-trails/" target="_blank">on</a> <a href="http://lists.w3.org/Archives/Public/www-tag/2010Feb/0002.html" target="_blank">anything</a> <a href="http://www.mail-archive.com/public-lod@w3.org/msg04387.html" target="_blank">related</a> <a href="http://masinter.blogspot.com/2010/03/resources-are-angels-urls-are-pins.html" target="_blank">to</a> <a href="http://www.webofthings.com/2010/02/02/sharing-in-a-web-of-things/" target="_blank">the</a> <a href="http://highscalability.com/blog/2010/3/26/strategy-caching-404s-saved-the-onion-66-on-server-time.html" target="_blank">Web</a>, various <a href="http://lists.w3.org/Archives/Public/public-lod/2010Mar/0203.html" target="_blank">specifics</a> <a href="http://lists.w3.org/Archives/Public/www-tag/2010Mar/0045.html" target="_blank">concerning</a> <a href="http://www.mnot.net/cache_docs/" target="_blank">current</a> <a href="http://lists.w3.org/Archives/Public/www-tag/2009Dec/0070.html" target="_blank">and</a> <a href="http://www.kimchy.org/rest_and_web_sockets/" target="_blank">future</a> <a href="http://lists.w3.org/Archives/Public/ietf-http-wg/2010JanMar/0337.html" target="_blank">standards</a> and so on. And even more often, the <strong>discussions unnecessarily repeat previous discussions</strong> probably because the authors are unaware that the same discussion exists elsewhere or it's that those are too difficult to search for. For example, the HATEOAS constraint is getting <a href="http://weblogs.java.net/blog/mkarg/archive/2010/02/14/what-hateoas-actually-means" target="_blank">a</a> <a href="http://www.amundsen.com/blog/archives/1005" target="_blank">lot</a> <a href="http://www.slideshare.net/skillsmatter/hydras-and-hypermedia" target="_blank">of</a> <a href="http://www.infoq.com/articles/mark-baker-hypermedia" target="_blank">attention</a> <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_blank">everywhere</a>. So there's lots of unorganized, scattered, duplicated and mutually disconnected fragments on REST and it's unclear where and how to find the ones that answer your questions. No, <a href="http://www.google.com/search?hl=en&amp;q=REST" target="_blank">Googling</a> won't help as often as you'd like, no, a <a href="http://www.infoq.com/minibooks/emag-03-2010-rest" target="_blank">series of unrelated articles</a> piled up together won't either (though <a href="http://twitter.com/mamund" target="_blank">Mike Amundsen's tweets</a> often will), and yes, a-big-unorganized-mess is kind of the point of the Web in general, however it's not the optimal methodology for <strong>systematizing knowledge in a way required</strong><strong> for understanding complex concepts like REST</strong>.</p>

<img class="aligncenter" src="http://images.ctv.ca/archives/CTVNews/img2/20080516/450_messy1_080516.jpg" width="325" height="225" />

<p style="text-align:justify;">Third, these <strong>fragments on REST often use mutually different terminology, same terminology with different meaning</strong><strong> or terminology which is not explicitly defined</strong>. My favorite example is the word "state" which is overloaded with unexplained and overlapping meaning. "Resource state", "session state", "control state", "client state", "server state", "application state", "transaction state", "steady state" and "transient state" are some of the terms used and it is not completely clear what some of those mean, how they are related and which REST elements use, change and transfer them and when. For example, <a href="http://tech.groups.yahoo.com/group/rest-discuss/message/14671" target="_blank">what is client state</a>? Is it something related to the client connector type? Is it something stored on the client component? If so, then <a href="http://tech.groups.yahoo.com/group/rest-discuss/message/15074" target="_blank">why is it not called user agent</a> state? Is client state a union of session and application state? Or is application state a synonym for session state? Which states does a <a href="http://tech.groups.yahoo.com/group/rest-discuss/message/14643" target="_blank">steady state relate to</a> - client, session or application? Which entities may change session state and when? Yes, some of these concepts are completely clear, <a href="http://tech.groups.yahoo.com/group/rest-discuss/message/15116" target="_blank">but some are not</a> and different people use them with different meaning. Still, the most entertaining situations are the ones in which people write only "state" and then you have to figure out which state they are referring to. Yeah, good luck. And there are other both simple and complex examples, from stating that REST methods are to be executed over representations instead of resources and discussing if ATOM is <a href="http://tech.groups.yahoo.com/group/rest-discuss/message/15061" target="_blank">RESTful</a> <a href="http://tech.groups.yahoo.com/group/rest-discuss/message/14718" target="_blank">or not</a> to explaining just what is an <em>application </em>in terms of REST. Lastly, similar to Roy's dissertation, these discussion rarely use diagrams or formal models to explain anything.</p>
<p style="text-align:justify;">These problems confuse people trying to learn REST on a basic level and make it hard to discuss REST on deeper levels.</p>

<h2>What we should do about it</h2>
<p style="text-align:justify;">Now, I'm not implying that these problems will cause the apocalypse if we don't solve them, but I'd sure like it if they go away (and lots of other people would also). So here are my suggestions:</p>
<p style="text-align:justify;">First, <strong>a mess is still better than nothing</strong>. Everyone should at least continue with thinking, writing and talking about REST and create more fragments. Chances are that those fragments will help a fair amount of people interested in REST. I definitely learned a lot from <a href="http://www.markbaker.ca/blog/" target="_blank">reading</a> <a href="http://amundsen.com/blog/" target="_blank">excellent</a> <a href="http://www.nordsc.com/blog/" target="_blank">blogs</a>, <a href="http://www.twibes.com/group/rest?id=817190" target="_blank">tweets</a>, <a href="http://dret.net/netdret/publications" target="_blank">papers</a> and <a href="http://tech.groups.yahoo.com/group/rest-discuss/messages/14643?threaded=1&amp;m=e&amp;var=1&amp;tidx=1" target="_blank">mailing list posts</a> (Ryan's <a href="http://tomayko.com/writings/rest-to-my-wife" target="_blank">explanation of REST to his wife</a> is especially entertaining, besides educational).</p>
<p style="text-align:justify;">Second, I think this problem can and <strong>should be solved collaboratively and openly</strong>, not by single person (not even Roy Fielding) or as just another academic paper. If there's going to be agreement over terminology, it's meaning, models, and other ways of making understanding REST easier, this agreement must be backed by people who have relevant REST experience and must be open to comments from everyone else. Furthermore, untangling the mess will require a lot of work. So, in my opinion, the REST community (whatever that is) should:</p>

<div id="_mcePaste">
<ol>
	<li style="text-align:justify;">Agree that there is a problem worth fixing - do we think that we can create a better, clearer and more systematized way of understanding and discussing about REST?</li>
	<li style="text-align:justify;">Express interest in fixing it - is this something people want to contribute their time to?</li>
	<li style="text-align:justify;">Agree on how to fix it - what should be our output (a RESTopedia, a document, video tutorials) and how would we all contribute to and moderate the process?</li>
	<li style="text-align:justify;">Do it - spend time discussing and developing the output.</li>
	<li style="text-align:justify;">Eat our dogfood - use whatever we produce. If we don't use the terminology and models we agree upon, the the mess has only gotten bigger.</li>
</ol>
</div>

<img class="aligncenter" src="http://farm4.static.flickr.com/3199/3330670980_dab9f6b5c8.jpg" width="320" height="213" />

<p style="text-align:justify;"><a href="http://twitter.com/distobj" target="_blank">There</a> <a href="http://twitter.com/sallamar" target="_blank">are</a> <a href="http://twitter.com/guilhermecaelum" target="_blank">more</a> <a href="http://twitter.com/iansrobinson" target="_blank">than</a> <a href="http://twitter.com/mamund" target="_blank">enough</a> <a href="http://twitter.com/algermissen" target="_blank">smart</a> <a href="http://twitter.com/stilkov" target="_blank">and</a> <a href="http://twitter.com/dret" target="_blank">motivated</a> <a href="http://twitter.com/andrewwahbe" target="_blank">people</a> with different backgrounds and experience with REST and RESTful HTTP to make this happen and it would have a big impact if done (even more if done right). I myself am not sure what the best output would be and how to achieve it, but would like it to be a hypermedia document available freely on the WWW, contain a systematized intersection of terminology, images, models and rationale that everyone agrees upon and focus on REST, using HTTP/URI/HTML only for examples (not the other way around).</p>

<h2>Formal models for REST - a FSM model of a simplified RESTful user-agent</h2>
<p style="text-align:justify;">First off, <strong>developing useful formal models for understanding architectural styles isn't easy</strong> since architectural styles are named sets of constraints commonly defined using natural language, rarely using formalisms. Also, models of REST concepts should include as many other REST concepts as possible - e.g. a model of HATEOAS should somehow clear up how application state, representations, methods, resources, steady states, transient states and other concepts all play their role in HATEOAS. It's not easy to model this in a clear and simple way. Nevertheless, these kinds of models are especially important since they connect rather than disperse concepts.</p>
<p style="text-align:justify;">Mike Amundsen's and Jan Algermissen's <a href="http://www.amundsen.com/blog/archives/1032" target="_blank">poking</a> <a href="http://rest.hackyhack.net/2010-02-13.html#168/h168" target="_blank">at</a> <a href="http://tech.groups.yahoo.com/group/rest-discuss/messages/15101?threaded=1&amp;m=e&amp;var=1&amp;tidx=1" target="_blank">REST steady states</a> was very thought-provoking for me - excerpts pointing at something often ignored when discussing REST, but could be formally defined. This led me to try to model REST user-agents using some kind of a state machine. I soon found out there are lots of <a href="http://portal.acm.org/citation.cfm?id=267955&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=84620683&amp;CFTOKEN=34066621" target="_blank">interesting</a> <strong><a href="http://webpages.cs.luc.edu/~laufer/papers/isas95.pdf" target="_blank">papers</a> <a href="http://ieeexplore.ieee.org/iel5/10670/33674/01602332.pdf?arnumber=1602332 " target="_blank">on</a> <a href="http://portal.acm.org/citation.cfm?id=366869&amp;dl=GUIDE&amp;coll=GUIDE&amp;CFID=84620229&amp;CFTOKEN=91600605" target="_blank">modeling </a><a href="http://portal.acm.org/citation.cfm?id=267449" target="_blank">hypermedia</a> <a href="http://www.cs.auckland.ac.nz/compsci345s1c/lectures/formcharts.pdf" target="_blank">applications</a></strong><strong> in general</strong> and <a href="http://intertwingly.net/blog/2005/03/09/Distributed-State-Machines" target="_blank">even</a> <a href="http://weblogs.java.net/blog/2007/04/27/rest-state-machine-duh" target="_blank">more</a> <strong><a href="http://www.pluralsight-training.net/community/blogs/tewald/archive/2007/04/26/46984.aspx" target="_blank">blogs</a> on modeling REST user-agents</strong> using some kind of state machine formalism (<a href="http://en.wikipedia.org/wiki/Finite_state_machine" target="_blank">FSMs</a>, <a href="http://en.wikipedia.org/wiki/UML_state_machine" target="_blank">statecharts</a>, <a href="http://en.wikipedia.org/wiki/Petri_net" target="_blank">Petri nets</a> or something else). Here are some of my thoughts after reading these papers and blogs:</p>

<ol style="text-align:justify;">
	<li style="text-align:justify;">Most often, models are based on the "each page is a state and each link is a state transition" analogy. This is confusing and wrong for two reasons. First, it's confusing since resource identifiers (e.g. URIs) are used to somehow address states of the application (e.g. an URI addresses a page which is mapped to a state) and state transitions (e.g. an URI is a link to a state which is mapped to a transition). In REST, resource identifiers are neither the single thing determining the state (e.g. two clients can perform the same GET request on a resource and get different representations which determine state) nor the single thing determining the transition between states (e.g. one client can perform a GET on a resource, the other could perform a PUT). Roy's thesis defines what constitutes application state and thus when the state changes: "<em>An application's state is therefore defined by its pending requests, the topology of connected components, the active requests on those connectors, the data flow of representations in response to those requests, and the processing of those representations as they are received by the user agent.</em>" Second, models often ignore some REST concepts like steady and transient states and are therefore useful only for understanding REST up to a certain level.</li>
	<li>State machines models are extremely simple to understand and a powerful tool for modeling. For example, state machines can also be used for <a href="http://en.wikipedia.org/wiki/Model_checking" target="_blank">model checking</a> using <a href="http://en.wikipedia.org/wiki/Temporal_logic" target="_blank">temporal logic</a> (e.g. check that from any state there is a link to the home page).</li>
</ol>
<p style="text-align:justify;">That's why I really like Stu Charlton's <a href="http://www.stucharlton.com/blog/archives/2010/03/building-a-restful-hypermedia.html" target="_blank">recent post</a> on RESTful user-agents which identifies different types of state machines involved in user-agent operation. Stu nailed most of the things I wanted to write about, but nevertheless - below is my first attempt at a simplified finite state machine (FSM) model of RESTful user-agents. I won't go into explaining FSMs in detail, so just check the <a href="http://en.wikipedia.org/wiki/Finite_state_machine" target="_blank">Wikipedia article</a> if you don't know what FSMs are.</p>
<p style="text-align:justify;">I'll concentrate on recognizer-type finite state machines - specifically, <a href="http://en.wikipedia.org/wiki/Nondeterministic_finite-state_machine" target="_blank">nondeterministic FSMs (NFAs)</a>. NFAs are mathematically defined as a quintuple (Σ,<em>S</em>,<em>s</em><sub>0</sub>,δ,<em>F</em>), where</p>

<ul style="text-align:justify;">
	<li><span class="texhtml"><em>Σ</em></span> is the input <span style="color:#000000;">alphabet</span> (a finite, non-empty set of symbols).</li>
	<li><span class="texhtml"><em>S</em></span> is a finite, non-empty set of states.</li>
	<li><span class="texhtml"><em>s</em><sub><span style="font-size:medium;"><em>0</em></span></sub></span> is an initial state, an element of <span class="texhtml"><em>S</em></span>.</li>
	<li><span class="texhtml"><em>δ</em></span> is the state-transition function: <em>δ : S x Σ → P(S)</em> where <em>P(S)</em> the power set <em>S</em>.</li>
	<li><span class="texhtml"><em>F</em></span> is the set of final states, a subset of <span class="texhtml"><em>S</em></span>.</li>
</ul>
<p style="text-align:justify;">The operation of an NFA automaton, as state machines are sometimes called, is described as follows. The NFA starts from the initial state and then sequentially reads one input symbol at a time each time applying the state-transition function to transfer itself to the next state. After all input symbols have been processed in this way, the NFA stops and outputs "true" if the last state is in the set of final states, or "false" otherwise. Notice that it is not defined how input symbols are generated, just that there is a sequence of them being fed to the automaton. Also notice that NFAs can nondeterministically transfer to a set of states at some point. This <strong>nondeterminism is important but also confusing</strong> - how can the automaton be at more than a single state? Well, although the formal definition indicates that the automaton is in a set of states, the practical and useful meaning is that the automaton may be at any single state from that set - we don't know which one in advance, it can be any single one. In other words, a single state from the set will be chosen in some way e.g. using probabilities.</p>
<p style="text-align:justify;">This iterative process of automaton operation can be modeled as a system:</p>

<center>
<table>
<tbody>
<tr>
<td>
<pre>CurrentState = s<sub>0</sub>
while there are more input symbols to process:
  InputSymbol = GetNextInput()
  CurrentState =
    TransitionFunction(InputSymbol, CurrentState)</pre>
</td>
</tr>
<tr>
<td><center><img class="aligncenter" style="margin:5px;" src="/images/rest_system1.png" alt="" width="300" height="123" />
</center></td>
</tr>
</tbody>
</table>
</center>

<p style="text-align:justify;">Here, CurrentState is a component that stores the current state of the automaton, InputSymbol is a component that stores the current input symbol (element from the input alphabet), GetNextInput is a component that provides the next input symbol and writes it to the InputSymbol component and TransitionFunction is a component that computes the state transition function and writes the new state to the CurrentState component. Notice that the GetNextInput component doesn't take any input in this description. This is not entirely true, of course - the operation of the component that generates input symbols is out of scope of formal automaton definition, the component may generate input symbols based on whatever it wants. So, I'll expand the system to include the CurrentState as an input to the GetNextInput component (since there is nothing else in the model to include):</p>

<center>
<table>
<tbody>
<tr>
<td>
<pre>CurrentState = s<sub>0</sub>
while there are more input symbols to process:
  InputSymbol = GetNextInput(<span style="color:#ff0000;">CurrentState</span>)
  CurrentState =
    TransitionFunction(InputSymbol, CurrentState)</pre>
</td>
</tr>
<tr>
<td>
<center><img class="aligncenter" style="margin:5px;" src="/images/rest_system2.png" width="300" height="123" />
</center></td>
</tr>
</tbody>
</table>
</center>

<p style="text-align:justify;">Now the interesting part - <strong>mapping properties of RESTful user-agents to this NFA model</strong>. As I wrote before, this is a simplified first-draft-quality model, not everything that should be included is included and thus the model may change when more details do get included. First I'll try to explain the mapping in a general way, not on a specific RESTful system, and after that I'll give a concrete example:</p>

<ul>
	<li style="text-align:justify;"><strong>The input alphabet</strong> (set of input symbols generated by the GetNextInput component and stored in the InputSymbol component) are REST requests. Since a REST requests is defined by a resource identifier, method to be performed on the resource, metadata and a possible representation, the input alphabet is the set of all possible (syntactically) well-formed REST requests. This is why the resource identifier is not the only thing representing a transition - a single transition from a specific state is defined by all elements of a REST request, only one of which is the resource identifier. Therefore, there may be multiple transitions from a specific state and a specific destination resource identifier.</li>
	<li style="text-align:justify;"><span style="font-size:13.1944px;"><strong>The state transition function</strong>, implemented in the TransitionFunction component, is the cumulative processing of REST requests. This process is performed by user-agents, intermediaries and origin servers, and the result is a REST response containing metadata and a representation of the resource identified in the related REST request. Here's the most important part - since the user-agent doesn't know what the response to a request will be and since the origin server may return different REST responses for the same REST request - this processing must be modeled as nondeterministic. In other words, the result of the transition function is a set of all possible REST responses which may be returned for a given REST request. As I explained earlier when demystifying nondeterminism, the origin server will in fact return a single response but since we don't know which one - this is modeled as a set of possible responses. Also, the metadata (media type) of the response defines if the state is steady or not by specifying which of the resources linked to from the response representation should also be requested. If the state is not steady, more requests should be sent for those resources. If the input symbol is a REST request for a resource for which there is no link in the current state then the transition function returns an empty set. The same happens if the system is not in a steady state and the input symbol is a REST request not in the set of pending requests.</span></li>
	<li style="text-align:justify;"><strong>The current state</strong>, stored in the CurrentState component, is a set of REST responses and pending REST requests. The current state is considered a steady state if there are no pending requests, otherwise it's considered a transient state. <strong>The initial state</strong> of the user-agent is steady and may contain a predefined representation with links to bootstrap the operation of the user-agent.</li>
	<li style="text-align:justify;">The only thing left is to define how the user-agent chooses transitions - the next REST request for the current state. This is the role of the GetNextInput component which implements both application- and hypermedia-level logic. The application-level logic is in charge of generating input symbols in case the current state is steady, or in other words, it chooses then next step for achieving the overall application goal. The application-level logic may be a software program or a program that delegates this responsibility to a human user. The hypermedia-level logic is in charge of generating input symbols in case the current state is transient, or in other words, it chooses which of the pending REST requests will be processed next. To satisfy the HATEOAS constraint, both the application- and hypermedia- level logic generate REST requests with resource identifiers linked to from the current state.</li>
</ul>

<img class="aligncenter" src="/images/rest_system3.png" alt="" width="600" height="383" />

Or mathematically (without all the detailed explanations):
<ul style="text-align:justify;">
	<li><span class="texhtml"><em>Σ</em></span> = { <em>R</em> | <em>R</em> is a valid REST request consisting of a resource identifier, method, metadata and representation }</li>
	<li><span class="texhtml"><em>S</em></span> = { { <em>G</em> } | <em>G</em> is a valid REST response consisting of metadata and a representation or a pending REST request }</li>
	<li><span class="texhtml"><em>s</em><sub><span style="font-size:medium;"><em>0</em></span></sub></span> = initial representation containing links to bootstrap the operation of the user agent</li>
	<li><em>δ : S x Σ → P(S)</em> where <em>P(S)</em> the power set of <em>S</em>.</li>
	<li><span class="texhtml"><em>F</em></span> = { <em>Z</em> | <em>Z</em> ∈ <em>S</em> and <em>Z</em> is a steady state }</li>
</ul>
<p style="text-align:justify;">The operation of the automaton can be described as follows. The automaton starts from the initial steady state containing links for bootstrapping the application. Each time the automaton is in a steady state, the application level logic generates the next input symbol (request) based on the links in the current state representations and the overall application goal. The request and the current state are used by the processing infrastructure (user-agent, intermediaries, origin server) to generate a response. Notice here that the current state (representation already on the client) need not be sent to the server, it may be used on the user-agent for processing (e.g. to determine if the request is for a resource linked to from the current state or not) while only the input symbol (the request) is sent over the network. The result of the processing is the new state of the user-agent. The new state may either be steady or transient, based on the representation received in the response and it's metadata (media type). If the state is transient, the hypermedia-level logic automatically chooses requests for fetching other resources in order to bring the user-agent into a steady state so that application-level logic can take over.</p>

<img class="aligncenter" src="/images/rest_example1.png" alt="" width="400" height="340" />

<p style="text-align:justify;">Now an <strong>example - applying this model to a specific RESTful system</strong>, which will of course be a simple web application shown above. The purpose of the web application is to simulate coin tossing. It has two web pages, <em>Main.html</em> and <em>Cointoss.html</em>. The <em>Main.html</em> page contains only a single link to the <em>Cointoss.html</em> page and nothing else. The <em>Cointoss.html</em> page has a link back to the <em>Main.html</em> page and a single image. Since the web application simulates coin tossing, which is nondeterministic, the image which gets included into the <em>Cointoss.html</em> is chosen randomly by the server and is either the <em>heads.png</em> image or the <em>tails.png</em> image.</p>
<p style="text-align:justify;">The input symbols of the resulting automaton are requests for fetching application resources - the html pages and the images. The states of the resulting automaton are both steady states representing a complete page load or transient states representing partial page loads. Therefore, the <em>Main.html</em> page is represented by only a steady state since it only contains a link to <em>Cointoss.html</em>, while the <em>Cointoss.html</em> page is represented by both a transient state and a steady state since it contains an image which must be fetched after the initial page. Let's assume that the initial state contains a single link to the <em>Main.html</em> page. The transition function of the resulting automaton defines which responses the processing infrastructure returns for each state and requests. Therefore, if the user-agent requests a page or image, the server returns the requested page or image. However, if the user-agent is requesting the <em>Cointoss.html</em> page - it isn't known in advance what the server will return (heads or tails), so we need a nondeterministic transition into two possible states. Lastly, steady states define the set of acceptable states.</p>
<p style="text-align:justify;">And here's the formal automaton definition for the explanation above:</p>

<ul style="text-align:justify;">
	<li><span class="texhtml"><em>Σ</em></span> = { <em>R1</em>, <em>R2</em>, <em>R3</em>, <em>R4</em> }, where <em>R1</em> is a request for fetching <em>Main.html</em>, <em>R2</em> is a request for fetching <em>Cointoss.html</em>, and <em>R3</em> and <em>R4</em> are requests for fetching the <em>heads.png</em> and <em>tails.png</em> images. For simplicity, let's say these are the only input symbols the user-agent may generate, but in general - it may generate other syntactically valid requests.</li>
	<li><span class="texhtml"><em>S</em></span> = { <em>S1</em>, <em>S2</em>, <em>S3</em>, <em>S4</em>, <em>S5</em>, <em>S6</em>}, where <em>S1</em> is the initial state containing a link to <em>Main.html</em>, <em>S2 </em>is the state after receiving the <em>Main.html</em> page, <em>S3 </em>is the state after receiving the <em>Cointoss.html</em> page which has a link to the <em>heads.png</em> image which hasn't been fetched yet, <em>S4</em> is the state after receiving responses to both the <em>Cointoss.html</em> page and <em>heads.pn</em>g, <em>S5 </em>is the state after receiving the <em>Cointoss.html</em> page which has a link to the <em>tails.png</em> image which hasn't been fetched yet and <em>S6 <span style="font-style:normal;">is the state after receiving responses to both the <em>Cointoss.html</em> page and <em>tails.pn</em>g.</span></em></li>
	<li><span class="texhtml"><em>s</em><sub><span style="font-size:medium;"><em>0</em></span></sub></span> = <em>S1</em>, since <em>S1</em> is the initial state.</li>
	<li>The transition function is defined for each pair of automaton state and input symbol: <em>δ</em>(<em>S1</em>, <em>R1</em>) = <em>S2</em>, <em>δ</em>(<em>S2</em>, <em>R2</em>) = {<em>S3</em>,<em> S5</em>}<em>,</em> <em>δ</em>(<em>S3</em>, <em>R3</em>) = <em>S4</em>, <em>δ</em>(<em>S4</em>, <em>R1</em>) = <em>S2</em>, <em>δ</em>(<em>S5</em>, <em>R4</em>) = <em>S6</em>, <em>δ</em>(<em>S6</em>, <em>R1</em>) = <em>S2. </em>For other pairs of state and input symbol the function returns an empty set { } since there are no other links for those pages (states) to resources identified in those requests (input symbols).</li>
	<li><span class="texhtml"><em>F</em></span> = { <em>S1</em>,<em> S2</em>,<em> S4</em>,<em> S6</em> }, since those states are steady.</li>
</ul>
And here's the equivalent state diagram visualization of the automaton:
<p style="text-align:center;"></p>

<img class="aligncenter" src="/images/rest_example2.png" width="100%"/>

For such a model, we could generate a random sequence of input symbols and check if the automaton will end up in a steady state or not. You can do this for homework :).
<h2>Conclusion</h2>
<p style="text-align:justify;">(<strong><em>EDIT: inserted a few sentences to make this a real conclusion</em></strong>) That's about it. All-in-all, I think REST is an important concept for the WWW and that more work should be done to explain it fully and concisely. After that, we can simplify the models to reflect the most important properties, but simplifying before understanding leads to ignorance and <em>mis</em>understanding in discussions.</p>
<p style="text-align:justify;">If you have ideas or comments about systematizing knowledge, terminology and models for REST or developing formal models for REST - let me know. <a href="http://www.twitter.com/izuzak" target="_blank">@izuzak</a></p>

